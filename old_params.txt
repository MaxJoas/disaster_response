parameters = {
        # 'features__text_pipeline__vect__ngram_range': ((1, 1), (1, 2)),
        # 'features__text_pipeline__vect__max_df': (0.5, 0.75, 1.0),
        # 'features__text_pipeline__vect__max_features': (None, 5000, 10000),
        # 'features__text_pipeline__tfidf__use_idf': (True, False),
        # 'clf__estimator__n_estimators': [50, 75],
        'clf__estimator__max_iter': [50, 100]
        # 'clf__estimator__min_samples_split': [2, 3, 4],
        # 'features__transformer_weights': (
        #     {'text_pipeline': 1, 'starting_verb': 0.5},
        #     {'text_pipeline': 0.5, 'starting_verb': 1},
        #     {'text_pipeline': 0.8, 'starting_verb': 1},
        # )
    }

class PosFrequency(BaseEstimator, TransformerMixin):

    def __init__(self, pos_tag='NN'):
        self.pos_tag = pos_tag

    def fit(self, X, y=None):
        return self

    def transform(self, X):
        X_counted = pd.Series(X).apply(lambda x: self.pos_frequency(x)).values
        res = pd.DataFrame(X_counted)
        res.fillna(0, inplace=True)
        return res

    def pos_frequency(self, text):
        counter = 0
        tokenized = tokenize(text)
        pos_tags = nltk.pos_tag(tokenized)
        for tag in pos_tags:
            if tag[1] == self.pos_tag:
                counter += 1
                return round(counter / len(tokenized))
